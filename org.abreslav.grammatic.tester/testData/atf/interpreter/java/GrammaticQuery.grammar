#import 
	'GrammaticLexer.grammar'{NAME}, 
	'GrammaticMetadata.grammar'{attributeValue},
	'GrammaticGrammarTemplate.grammar'{lexicalAtomIndependent};

ruleQueryContainer
	: symbolQueryWithVar productionQuery* ';'
	;

variablePrefix
	: '$' NAME? '='
	;
		
symbolQueryWithVar
	: variablePrefix? anonymousSymbolQuery
	: namedSymbolQuery
	;
		
anonymousSymbolQuery
	: '#'
	: '@' queryMetadata '@'
	;
	
namedSymbolQuery
	: NAME
	;

symbolReferenceQuery
	: anonymousSymbolQuery
	: namedSymbolQuery
	;
		
productionQuery 
	: variablePrefix? (':' | '|:') alternativeQuery
	: ':' variablePrefix? '{...}'
	;
	
expressionQuery
	: alternativeQuery ';'
	;
	
alternativeQuery
	: sequenceQuery ('|' (sequenceQuery | (variablePrefix? '...')))*
	;

sequenceQuery
	: iterationQuery+
	;
	
iterationQuery
	: varOrAtom (queryMetadata)? operation
	: variablePrefix? '..'
	;
	
operation 
	: '*' | '+' | '?'
	: #empty
	;

varOrAtom
	: atom
	:  variablePrefix atom
	;

atom
	: symbolReferenceQuery
	: '$' NAME
	: '(' alternativeQuery ')'
	: lexicalAtom
	: '#lex'
	: '#empty'
	;
	
queryMetadata 
	: '{' (attributeQuery (';' attributeQuery?)*)? '}'
	;

attributeQuery 
	: attributeWithValueQuery
	: '!' namespaceUri? NAME
	: namespaceUri? NAME ':' attributeType 
	;		 

attributeWithValueQuery
	: namespaceUri? NAME ('=' attributeValue)?
	;
	
namespaceUri
	: NAME ':'
	;

attributeType
	: '#' NAME
	;
	
////////////////////////////////////////////////
	
lexicalAlternative
	: lexicalSequence ('|' lexicalSequence)*
	;

lexicalSequence
	: lexicalIteration+
	;
	
lexicalIteration
	: lexicalAtom operation
	;
	
lexicalAtom
	: lexicalAtomIndependent
	: '[[' lexicalAlternative ']]'
	;