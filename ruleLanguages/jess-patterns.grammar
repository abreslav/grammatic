#import {VARIABLE, MULTIFIELD}, {functionCall};

conditionalElement
	: conditionalElementBody 
	: patternBinding
	;
	
conditionalElementBody
	: bindable
	: '(' 'and' conditionalElement+ ')'
	: '(' 'or' conditionalElement+ ')'
	: '(' 'logical' conditionalElement+ ')'
	: '(' 'forall' conditionalElement conditionalElement+ ')'
	: '(' 'exists' conditionalElement ')'
	: '(' 'not' conditionalElementBody ')' // all variables are local
	: '(' 'test' functionCall ')' // boolean result! all vars are local
	: '(' 'unique' conditionalElement+ ')' // ignored
	;

bindable
	: pattern
	: '(' 'accumulate' functionCall functionCall expression conditionalElement ')' // ???
	;

pattern
	: '(' topLevelName (simplePattern | slotPattern)* ')'
	: '(' topLevelName tests* ')' // ordered facts
	;

patternBinding
	: VARIABLE '->' bindable // conditionalElement?
	;
	
test
	: VARIABLE
	: number | nonVariableSymbol // literal value
	: ':' functionCall
	: '=' functionCall
	: '~' test
// unsupported
//	: '/' JAVA_REG_EXP '/'
	; 
	
tests
	: (VARIABLE | MULTIFIELD)? testExpression? // ambiguity: we cannot syntactically distinguish
								// a variable which is bounded here from
								// the one which is used here
								// semantically advised parsing needed!
	;
	
testExpression
	: testConjunction ('|' testConjunction)*
	;

testConjunction
	: testAtom ('&' testAtom)*
	; 
	
testAtom
	: test
	//: '(' testExpression ')' // ~ is forbidden for use before ()
	;
	
simplePattern
	: '{' infixExpression '}'
	;
	
patternComparison
	: '<' | '>' | '<=' | '>=' | '==' | '!=' | '<>'
	;

infixExpression
	: infixConjunction ('||' infixConjunction)*
	;
	
infixConjunction
	: infixAtom ('&&' infixAtom)*	
	;
	
infixAtom
	: '(' infixExpression ')'
	: nonVariableSymbol patternComparison expression
	;