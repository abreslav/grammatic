program
	@program : Program
	: statement{program.statements+=#}*
	;

statement
	@statement : Statement
	: expression{..}
	: defmodule{statement=#}
	: defglobal{..}
	: deftemplate{..}
	;

STRING : '"'{skip} ('\'{skip} '"' | [^ '"'])* '"'{skip};

boolean {instanceType: boolean}
	: TRUE{true}
	: FALSE{false}
	;

defmodule
	@module : Module
	$=: nonVariableSymbol{module.name=#} 
	  STRING{module.comment=#}? 
	  boolean{module.autoFocus=#}?
	;
:: {
	before = '(' 'defmodule'
	after = ')'
	boolean.before = '(' 'auto-focus'
	boolean.after = ')'
}
/* Result
defmodule
	@module : Module
	: '(' 'defmodule' 
		nonVariableSymbol{module.name=#} 
		STRING{module.comment=#}? 
		('(' 'auto-focus' boolean{module.autoFocus=#} ')')?
	;
*/

defglobal
	@global : Global
	: $body=(GLOBAL_VARIABLE{global.name=#} expression{global.value=#})
	;
:: {
	[3.2] inline(defglobal); [7] delete(defglobal)
	statement
		: (@global : Global;
			GLOBAL_VARIABLE{global.name=#} expression{global.value=#}
		  ){statement=#}
		: {...}
		;
	[3.2] inline(statement); [7] delete(statement)
	program
		: (expression | defmodule | deftemplate 
		   | $body=(GLOBAL_VARIABLE expression)){program.statements+=#}*
		;
	[prop. 8] approx, there are some more steps
	/// SOMETHING MUST PREVENT US FROM SKIPPING THIS STEP
	///   Actually it is assigning the same variable twice (the variable is omitted here)
	/// DOUBTS IF THIS COULD BE DONE AUTOMATICALLY
	///   And we would like to hide most annotations from the user 
	program
		: (expression{program.statements+=#} | defmodule{program.statements+=#} | deftemplate{program.statements+=#} 
		   | $body=(GLOBAL_VARIABLE expression){program.statements+=#})*
		;
	[prop. 7] $iterated = introduce(+, $body) // it stays in alternative under *
	program
		: (expression | defmodule | deftemplate 
		   | $iterated=((GLOBAL_VARIABLE expression){program.statements+=#}+))*
		;
	[4.1 + ???] $iterated.before = '(' 'defglobal'
	[4.1 + ???] $iterated.after = ')'
	... '(' 'defglobal' (GLOBAL_VARIABLE expression)+ ')'...
	[3.2 + introduce new] ::program: ($statement)*; extract(statement: $statement);
	statement{(program)}
		: expression | defmodule | deftemplate | $iterated=((GLOBAL_VARIABLE expression){program.statements+=#}+)
		;
	[2.2] verticalize(statement)
	statement{(program)}
		: expression 
		: defmodule 
		: deftemplate 
		: $iterated=('(' 'defglobal' (GLOBAL_VARIABLE expression){program.statements+=#}+ ')')
		;
	[3.2 + introduce new] extract(defglobal: $iterated);  	
	statement{(program)}
		: expression 
		: defmodule 
		: deftemplate 
		: defglobal{(program)}
		;
	defglobal{(program)}
		: '(' 'defglobal' 
			(@global : Global;
				GLOBAL_VARIABLE{global.name=#} expression{global.value=#}
			){program.statements+=#}+ ')'
		;
}
 
slotKind
	: 'slot'
	: 'multislot'
	;
	
slot
	: slotKind nonVariableSymbol // check for dot absence in the name
	  $declarations=(slotType*
      default*
      defaultDynamic*
      allowedValues*)
    ;
:: {
	before
	after
	mergeIntoAlternative(slotType*, default*, defaultDynamic*, allowedValues*)
}

deftemplate
	: nonVariableSymbol STRING? // inlined module citizen and named and commented
	  defmodule& 
	  ($super=deftemplate&)? // super
	  slotSpecific*
      backchainReactive*
      fromClass*
      includeVariables* 
      ordered*
      slot* // forbidden if declared ordered
	;
:: {
	before
	after
	representReference(defmodule&, $module=nonVariableSymbol -- key in MODULES)
	$module.after = '::'
	extract(topLevelName: $module '::' nonVariableSymbol)
	$super.before = 'extends'
	representReference($super, 
		$superModule=nonVariableSymbol -- key in MODULES
		$superName=nonVariableSymbol -- key in $superModule::TEMPLATES)
	$superName.before = '::'
	move(STRING?, slotSpecific?.before)
	$declarations = mergeIntoAlternative(...)
	replaceIteration(?, $declarations)
	::$declarations == $body?
	extract(templateDeclarations: $body)
}