// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.4,
// (C) 2004-2009 Robert Grimm,
// on Wednesday, February 2, 2011 at 7:44:28 PM.
// Edit at your own risk.
// ===========================================================================

package org.abreslav.grammar.parser;

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import org.abreslav.grammar.*;
import org.abreslav.grammar.impl.*;
import java.util.*;

/**
 * Packrat parser for grammar <code>grammar</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.4, (C) 2004-2009 Robert Grimm.
 */
public final class Grammar extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fExpression;
    Result fSequence;
    Result fSequence$$Star1;
    Result fAtomicExpression;
    Result fIteration;
    Result fNEGATE;
    Result fIdentifier;
    Result fId;
    Result fId$$Star1;
    Result fSpacing;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fEOL;
    Result fEOF;
    Result fCharacterLit;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class GrammarColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Grammar(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Grammar(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new GrammarColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Grammar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pGrammar(final int yyStart) throws IOException {
    Result        yyResult;
    List<ISymbol> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSymbols(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEOF(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = resolveReferences();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Symbols.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbols(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pSymbol(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<Object> yyRepValue1;
    ISymbol      yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pLabel(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Object>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for labels.
      Pair<String> labels = cast(yyRepValue1.reverse());

      yyResult = pIdentifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String id = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCOLON(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IExpression v$el$2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              yyRepValue1   = new Pair<Object>(v$el$2, yyRepValue1);
              continue;
            }
          }
          break;
        }

        if (yyRepeated1) {
          Pair<IExpression> prods = cast(yyRepValue1.reverse());

          yyResult = pSEMI(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Iterator<IExpression> it = prods.iterator();
            IExpression first = it.next();
            ISymbol symbol = new SymbolImpl(labels, id, it.hasNext() ? new AlternativeImpl(prods) : first);
            addSymbol(symbol);
            yyValue = symbol;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    } // End scope for labels.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Label.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLabel(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.At.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAt(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('@' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("at expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpression) 
      yyColumn.chunk1.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk1.fExpression;
  }

  /** Actually parse grammar.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result      yyResult;
    IExpression yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlternative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Alternative.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAlternative(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<IExpression> yyRepValue1;
    IExpression       yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IExpression v1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pOR(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyResult = pSequence(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            IExpression v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<IExpression>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for rest.
        Pair<IExpression> rest = yyRepValue1.reverse();

        if (rest.isEmpty()) {
          yyValue = v1;
        } else {
          yyValue = new AlternativeImpl(v1, rest);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for rest.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Sequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSequence(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSequence) 
      yyColumn.chunk1.fSequence = pSequence$1(yyStart);
    return yyColumn.chunk1.fSequence;
  }

  /** Actually parse grammar.Sequence. */
  private Result pSequence$1(final int yyStart) throws IOException {
    Result      yyResult;
    IExpression yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIteration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IExpression v1 = yyResult.semanticValue();

      yyResult = pSequence$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<IExpression> rest = yyResult.semanticValue();

        if (rest.isEmpty()) {
          yyValue = v1;
        } else {
          yyValue = new SequenceImpl(v1, rest);
        }

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal grammar.Sequence$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSequence$$Star1(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSequence$$Star1) 
      yyColumn.chunk1.fSequence$$Star1 = pSequence$$Star1$1(yyStart);
    return yyColumn.chunk1.fSequence$$Star1;
  }

  /** Actually parse grammar.Sequence$$Star1. */
  private Result pSequence$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Pair<IExpression> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIteration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IExpression v$el$1 = yyResult.semanticValue();

      yyResult = pSequence$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<IExpression> v$2 = yyResult.semanticValue();

        yyValue = new Pair<IExpression>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.AtomicExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAtomicExpression(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAtomicExpression) 
      yyColumn.chunk1.fAtomicExpression = pAtomicExpression$1(yyStart);
    return yyColumn.chunk1.fAtomicExpression;
  }

  /** Actually parse grammar.AtomicExpression. */
  private Result pAtomicExpression$1(final int yyStart) throws IOException {
    int         yyC;
    int         yyIndex;
    Result      yyResult;
    int         yyBase;
    IExpression yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEmpty(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSymbolReference(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pCharacterRange(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IExpression v = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (')' == yyC) {
              yyIndex = yyResult.index + 1;

              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = v;

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("atomic expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Iteration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIteration(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIteration) 
      yyColumn.chunk1.fIteration = pIteration$1(yyStart);
    return yyColumn.chunk1.fIteration;
  }

  /** Actually parse grammar.Iteration. */
  private Result pIteration$1(final int yyStart) throws IOException {
    int         yyC;
    int         yyIndex;
    Result      yyResult;
    IExpression yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAtomicExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IExpression e = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '?':
            {
              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new OptionImpl(e);

                return yyResult.createValue(yyValue, yyError);
              }
            }
            break;

          case '*':
            {
              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new RepetitionImpl(e, RepetitionKind.ZERO_OR_MORE);

                return yyResult.createValue(yyValue, yyError);
              }
            }
            break;

          case '+':
            {
              yyResult = pSpacing(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new RepetitionImpl(e, RepetitionKind.ONE_OR_MORE);

                return yyResult.createValue(yyValue, yyError);
              }
            }
            break;

          default:
            /* No match. */
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pAtomicExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("iteration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.SymbolReference.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolReference(final int yyStart) throws IOException {
    Result           yyResult;
    ISymbolReference yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String id = yyResult.semanticValue();

      SymbolReferenceImpl impl = new SymbolReferenceImpl(null);
      yyValue = impl;
      references.put(impl, id);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Empty.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEmpty(final int yyStart) throws IOException {
    Result     yyResult;
    IEmpty     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    if (yyResult.hasValue("empty")) {

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = EmptyImpl.INSTANCE;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("empty expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    ILiteral   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String str = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new LiteralImpl(str);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.CharacterRange.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterRange(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    String          yyOpValue1;
    ICharacterRange yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pNEGATE(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for neg.
      String neg = yyOpValue1;

      yyResult = pCharacterLit(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String ch = yyResult.semanticValue();

        yyValue = new CharacterRangeImpl(neg != null, toChar(ch), toChar(ch));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for neg.

    // Alternative 2.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pNEGATE(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        String v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for neg.
        String neg = yyOpValue1;

        yyResult = pCharacterLit(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String from = yyResult.semanticValue();

          yyResult = pMINUS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCharacterLit(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String to = yyResult.semanticValue();

              yyResult = pRBRACKET(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new CharacterRangeImpl(neg != null, toChar(from), toChar(to));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      } // End scope for neg.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.LBRACKET.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLBRACKET(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LBRACKET expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.RBRACKET.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRBRACKET(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RBRACKET expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.NEGATE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNEGATE(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNEGATE) 
      yyColumn.chunk1.fNEGATE = pNEGATE$1(yyStart);
    return yyColumn.chunk1.fNEGATE;
  }

  /** Actually parse grammar.NEGATE. */
  private Result pNEGATE$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "!";

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("NEGATE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.COLON.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOLON(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COLON expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.SEMI.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSEMI(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("SEMI expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.OR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("OR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.MINUS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMINUS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("MINUS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIdentifier) 
      yyColumn.chunk1.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk1.fIdentifier;
  }

  /** Actually parse grammar.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fId) yyColumn.chunk1.fId = pId$1(yyStart);
    return yyColumn.chunk1.fId;
  }

  /** Actually parse grammar.Id. */
  private Result pId$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pId$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal grammar.Id$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId$$Star1(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fId$$Star1) 
      yyColumn.chunk1.fId$$Star1 = pId$$Star1$1(yyStart);
    return yyColumn.chunk1.fId$$Star1;
  }

  /** Actually parse grammar.Id$$Star1. */
  private Result pId$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pId$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSpacing) 
      yyColumn.chunk1.fSpacing = pSpacing$1(yyStart);
    return yyColumn.chunk1.fSpacing;
  }

  /** Actually parse grammar.Spacing. */
  private Result pSpacing$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSLComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pMLComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pEOL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.SLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '\n':
            case '\r':
              /* No match. */
              break;

            default:
              {
                yyRepetition1 = yyIndex;
                continue;
              }
            }
          }
          break;
        }

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyResult = pEOL(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pEOF(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("s l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.MLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '*':
              {
                yyPredMatched = false;

                yyC = character(yyIndex);
                if ('/' == yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyRepetition1 = yyIndex;
                  continue;
                } else {
                  yyError = yyError.select("m l comment expected", yyStart);
                }
              }
              break;

            default:
              {
                yyRepetition1 = yyIndex;
                continue;
              }
            }
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('*' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'*/' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("m l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.EOL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOL(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fEOL) yyColumn.chunk2.fEOL = pEOL$1(yyStart);
    return yyColumn.chunk2.fEOL;
  }

  /** Actually parse grammar.EOL. */
  private Result pEOL$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("EOL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.EOF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOF(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fEOF) yyColumn.chunk2.fEOF = pEOF$1(yyStart);
    return yyColumn.chunk2.fEOF;
  }

  /** Actually parse grammar.EOF. */
  private Result pEOF$1(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOF expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.CharacterLit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterLit(final int yyStart) throws IOException {
    GrammarColumn yyColumn = (GrammarColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCharacterLit) 
      yyColumn.chunk2.fCharacterLit = pCharacterLit$1(yyStart);
    return yyColumn.chunk2.fCharacterLit;
  }

  /** Actually parse grammar.CharacterLit. */
  private Result pCharacterLit$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.CharacterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCharContents(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v = yyResult.semanticValue();

        yyC = character(yyResult.index);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = v;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.CharContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharContents(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\"':
            case '\'':
            case '-':
            case '[':
            case '\\':
            case ']':
            case 'b':
            case 'f':
            case 'n':
            case 'r':
            case 't':
              {
                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'u':
              {
                yyResult = pHexQuad(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = difference(yyStart, yyResult.index);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.
          { // Start scope for nested choice.

            final int yyChoice2 = yyChoice1;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                            {
                              yyValue = difference(yyStart, yyIndex);

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
                {
                  final int yyChoice3 = yyIndex;

                  // Nested alternative 1.

                  yyC = character(yyChoice3);
                  if (-1 != yyC) {
                    yyIndex = yyChoice3 + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyValue = difference(yyStart, yyIndex);

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyValue = difference(yyStart, yyChoice3);

                  return new SemanticValue(yyValue, yyChoice3, yyError);
                }

              default:
                /* No match. */
              }
            }
          } // End scope for nested choice.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\'':
      case '\\':
        /* No match. */
        break;

      default:
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("char contents expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pStringContents(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v = yyResult.semanticValue();

        yyC = character(yyResult.index);
        if ('\"' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = v;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.StringContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringContents(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\\':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '\"':
              case '\'':
              case '-':
              case '[':
              case '\\':
              case ']':
              case 'b':
              case 'f':
              case 'n':
              case 'r':
              case 't':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              case 'u':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    continue;
                  }
                }
                break;

              default:
                /* No match. */
              }
            }

            // Nested alternative 2.
            { // Start scope for nested choice.

              final int yyChoice3 = yyChoice2;

              // Nested alternative 1.

              yyC = character(yyChoice3);
              if (-1 != yyC) {
                yyIndex = yyChoice3 + 1;

                switch (yyC) {
                case '0':
                case '1':
                case '2':
                case '3':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                              {
                                yyRepetition1 = yyIndex;
                                continue;
                              }

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }

              // Nested alternative 2.

              yyC = character(yyChoice3);
              if (-1 != yyC) {
                yyIndex = yyChoice3 + 1;

                switch (yyC) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                  {
                    final int yyChoice4 = yyIndex;

                    // Nested alternative 1.

                    yyC = character(yyChoice4);
                    if (-1 != yyC) {
                      yyIndex = yyChoice4 + 1;

                      switch (yyC) {
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                        {
                          yyRepetition1 = yyIndex;
                          continue;
                        }

                      default:
                        /* No match. */
                      }
                    }

                    // Nested alternative 2.

                    yyRepetition1 = yyChoice4;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
            } // End scope for nested choice.
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\"':
        case '\\':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            continue;
          }
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal grammar.HexQuad.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexQuad(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex quad expected", yyStart);
    return yyError;
  }

  // =========================================================================

  private final Map<String, ISymbol> symbols = new LinkedHashMap<String, ISymbol>();
  private final Map<SymbolReferenceImpl, String> references = new HashMap<SymbolReferenceImpl, String>();
  
  private void addSymbol(ISymbol symbol) {
    if (symbols.put(symbol.getName(), symbol) != null) {
      throw new IllegalArgumentException("Duplicate symbol: " + symbol.getName());
    }
  }
  
  private List<ISymbol> resolveReferences() {
    for (Map.Entry<SymbolReferenceImpl, String> entry : references.entrySet()) {
      ISymbol symbol = symbols.get(entry.getValue());
      if (symbol == null) {
        throw new IllegalArgumentException("Unresolved symbol: " + entry.getValue());
      }
      entry.getKey().setReferencedSymbol(symbol);
    }
    return new ArrayList<ISymbol>(symbols.values());
  }
  
  private static char toChar(String str) {
    if (str.length() == 1) {
      return str.charAt(0);
    }
    assert str.charAt(0) == '\\';
    switch (str.charAt(1)) {
      case '\\' : return '\\';
      case 'b'  : return '\b';
      case 't'  : return '\t';
      case 'n'  : return '\n';
      case 'f'  : return '\f';
      case 'r'  : return '\r';
      case '\'' : return '\'';
      case '\"' : return '\"';
      case 'u' : return hexToChar(str.substring(2, 6));
    }
    throw new IllegalStateException();
  }
  
  private static char hexToChar(String substring) {
    char result = 0;
    for (int i = 0; i < substring.length(); i++) {
      char c = substring.charAt(i);
      if (Character.isDigit(c)) {
        result = (char) (result * 16 + c - '0');
      } else if (Character.isUpperCase(c)) {
        result = (char) (result * 16 + c - 'A' + 10);
      } else {
        result = (char) (result * 16 + c - 'a' + 10);
      }
    }
    return result;
  }

}

// ===========================================================================

/*footer*/
